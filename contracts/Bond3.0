pragma solidity ^0.4.11;

contract SimpleBond 
{
    //STATE VARIABLES:
    address public Issuer;
    address public Lender;
    uint256 twentyPercent;
    uint256 Amount;
    
    //MAPPING:
    mapping(address => uint) balances;
    
    
    //MODIFIERS:
    modifier onlyIssuer()
    {
        if(msg.sender == Issuer)_;
        else throw;
    }
    
        modifier onlyLender()
    {
        if(msg.sender == Lender)_;
        else throw;
    }
    
    modifier release()
    {
        if(balances[Lender] == 0)_;
        else throw;
    }
    
    //PAYABLE FUNCTION:
    function Issuer20() payable
    {
        if(msg.sender !=Lender)
        {
        Issuer = msg.sender;
        twentyPercent = msg.value;
        Amount = 5*(this.balance);
        }
        else throw;
    }
    
    function lenderBond() payable returns(uint256 IssuerBal)
    {
        if(msg.sender != Issuer)
        { 
            Lender = msg.sender;
            if(msg.value != Amount)throw;
            balances[Issuer] += msg.value;
            return balances[Issuer];
        }
        else throw;
    }
    
    function issuerRepayment() payable onlyIssuer returns(uint256 lenderBal)
    {
        balances[Lender] += msg.value;
        return balances[Lender];
    }
    
    //WITHDRAW FUNCTIONS:
    function Withdraw(uint withdrawAmount) public returns (uint remainingBal) {
        if(msg.sender == Issuer)
        {
            if(balances[Issuer] >= withdrawAmount) {

                balances[Issuer] -= withdrawAmount;

                Issuer.transfer(withdrawAmount);
            
            }
            return balances[Issuer];
        }
        else if(msg.sender == Lender)
        {
                if(balances[Lender] >= withdrawAmount) {

                balances[Lender] -= withdrawAmount;

                Lender.transfer(withdrawAmount);
            }
            return balances[Lender];
        }
        
       
    }
    
    function lenderWithdrawSuccess(uint withdrawAmount) onlyLender public returns (uint remainingBal) {
        if(balances[Lender] >= withdrawAmount) {
            
            balances[Lender] -= withdrawAmount;
            balances[Issuer] += twentyPercent;
            
            Lender.transfer(withdrawAmount);
        }

        return balances[Lender];
    }
    

    function lenderTwentyPercent() constant onlyLender release returns (uint remainingBal)
    {
        balances[Lender] += twentyPercent;
        return balances[Lender];
    }
    
    function lenderWithdrawFail(uint withdrawAmount) onlyLender public returns (uint remainingBal) {
        if(balances[Lender] >= withdrawAmount) {
            // Note the way we deduct the balance right away, before sending - due to
            // the risk of a recursive call that allows the caller to request an amount greater
            // than their balance
            balances[Lender] -= withdrawAmount;

            Lender.transfer(withdrawAmount);
        }

        return balances[Lender];
    }
    
    
    //GETTERS:
    function getBalance() constant returns(uint256)
    {
        return this.balance;
    }
    
}
